TODO


register_vo_cud_throttled => on peut probablement pas throttle des méthodes qui sont annotés sans pbs....
intégrer une option     @ExecAsServer dans @runsonbgthread ou runsonmainthread

est-ce qu'on peut se passer de APIControllerWrapper.requestUrlMatchesApiUrl, quite à limiter aux apis de type post, postforget ?

1 - moduleparam.instance.xxx => avec un getter iso params de vars, qui s'auto supprime post init de l'instance. du coup c'est static en fait et on appel la fonction qu'une fois et ça marche pour tous les modules....
Autre option, peut-être encore plus simple, on init tous les modules en début d'appli (ce qui est surement déjà le cas) et donc après on n'a plus qu'à utiliser .instance tout le temps.

2 - au lieu de passer par un module api qui fourni un api handler côté serveur, si on peut, on remplace directement la méthode dans le module shared comme ça quand on l'appel coté serveur, on appel tout simplement la méthode du module serveur de façon transparente sans repasser par le module api

PushDataServerController.registeredSessions_by_uid => checkaccess => uid on envoie au thread principal directement une requete de delete de sessions by uid et osef tout le bgthread et le reste.
throw exception spécifique aux droits, catch dans l'api, et delete session directement là. tous les autres cas n'ont a priori pas de session à supprimer. attention aux changements de threads qui maintiennent la session ?=> faut transférer aussi l'exception
WTF AccessPolicyDeleteSessionBGThread
Si on peut supprimer ça simplifie la gestion des droits, on évite d'avoir besoin de la session de l'utilisateur..., mais cela dit si on veut invalider des sessions utilisateurs, on doit pouvoir les lier au user en base en fait, je comprends pas l'usage de ce bgthread...
Déprécier StackContext.get( StackContext.set( StackContext.runPromise( partout et si possible proposer une alternative avec paramètre uid et/ou is_client/is_server, ...


Register default translations dans le générateur pour les modules tables fields - inutile partout ailleurs - à la fin de la déclaration des types de contenus
ou a l'inverse il faudra vider du cache mémoire ModuleTableFieldController.GENERATOR_default_field_translations dès que c'est inutile (donc tout de suite ou après intégration des trads / jamais côté générateur)

Mettre un registeraccesshook qui vérifie le droit associé au moduletable si on n'est pas admin pour avoir le droit de download le moduletablevo et les ModuleTableFieldVO et les compositeuniquekeys


appeler :
ModuleTableController.init_field_name_to_api_map()
ModuleTableController.load_ModuleTableVOs_from_db()
ModuleTableController.init_unique_fields_by_voType()
ModuleTableController.init_readonly_fields_by_ids()


default_get_bdd_version => ModuleTableController. translate_vos_to_db
default_force_numeric && default_force_numerics => ModuleTableController. translate_vos_from_db

translate_field_from_db



define_default_label_function => ModuleTableController.set_label_function

delete public table_label_function: (vo: T) => string = null;
delete public table_label_function_field_ids_deps: string[] = null;


Séparer la déclaration des moduletablevo et moduletablefieldvo dans initialize_moduletablevos sur chaque module pour permettre de gérer facilement les problèmes de dépendances circulaires


Utilité de datatables dans les modules  ???

supprimé table.getFieldFromId
supprimé table.has_field_id